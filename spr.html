<!DOCTYPE html PUBLIC "-//W3C//DTD HTML 4.0 Transitional//EN">
<html>
<head>
    <!-- JS file containing list of sentences and comprehension questions. -->
    <script type="text/javascript" src="data.js"></script>

    <title>Self-paced reading</title>

    <style>
        body {
            color: black;
            background-color: white;
            font-size: small;
        }
        div.sentence {
            background-color: white;
        }
        p.question {
            padding-left: 0.6em;
        }
        div.sentence div {
            background-color: white;
            border-bottom: 1px solid;
            color: white;
            border-color: #9ea4b1;
            float: left;
	    margin-left: 0.6em;
            margin-bottom: 2em;
        }
        p.preamble {
            margin-left: 0.6em;
            margin-bottom: 2em;
        }
        .lpad {
            margin-left: 0.6em;
            margin-right: 0.6em;
        }
        div.bar-container {
            border: 1px solid;
            border-color: #9ea4b1;
            background-color: white;
        }
        div.bar {
            background-color: blue;
        }
        p.progress-text {
            padding-top: 0.5em;
            margin-top: 0;
            font-style: italic;
        }
        p.practice-text {
            color: red;
            font-weight: bold;
        }
        div.number-message {
            font-style: italic;
            margin-top: 0.5em;
        }
        p.next-sentence-message {
            font-style: italic;
        }
        p.finished-message {
            font-weight: bold;
            margin-top: 2em;
        }
    </style>
</head>
<body id="bod">

<!-- We set these to visible using JS, so that someone with JS disabled won't
     see this (assuming their browser has decent CSS support). -->
<div id="instructions" style="visibility: hidden; font-size: medium;">
<p class="lpad">
    <b>You will be presented with a number of sentences,
    each of which will initially appear with dashes in place of words.
    You can read each sentence one word at a time by repeatedly pressing
    the space bar.</b>
</p>
<p class="lpad">
    <b>After some sentences, you will be asked a comprehension question.
    Other times, another sentence will appear immediately with
    no intervening question.</b>
</p>
<p class="lpad">
    This page automatically sends the results to a server
    so that they can be collated. No details about you or your internet
    connection will be stored.
</p>
<p class="lpad">
    Please read at a speed that is natural for you (not as fast as you can!)
    You should also avoid reading aloud, since this can affect results.
    Feel free to wait as long as you like <i>between</i> sentences, but please
    don't take a break in the middle of a sentence.
</p>
<p class="lpad">
    <b>Press space to begin<b><script type="text/javascript">
    <!--
    // Are there any practice sentences?
    var hasPracticeSentences = false;
    for (var i = 0; i < sentences_strings.length; ++i) {
        if (sentences_strings[i][0] == 0) {
            hasPracticeSentences = true;
            break;
        }
    }
    if (hasPracticeSentences) {
        document.write(' <b>(you will get some practice sentences first).</b>');
    }
    else {
        document.write('<b>.</b>');
    }
    -->
    </script>
</p>
</div>

<script type="text/javascript">
<!--
var body = document.getElementsByTagName("body")[0];

function Sentence(type, preamble, words, question, num) {
    this.type = type;
    this.preamble = preamble;
    this.words = words;
    this.question = question;
    this.num = num;
}

var realSentences = new Array();
var fillerSentences = new Array();
var tempArrayOfPracticeSentences = new Array();
for (i = 0; i < sentences_strings.length; ++i) {
    var words = null;
    var preamble = null;
    var sString = null;
    if (typeof(sentences_strings[i][1]) == "string") {
        sString = sentences_strings[i][1];
    }
    else {
        sString = sentences_strings[i][1][1];
        preamble = sentences_strings[i][1][0];
    }
    words = sString.split(/\s+/);
    for (var j = 0; j < words.length; ++j) {
        words[j] = words[j].replace(/^\s+|\s+$/g,"");
    }

    var sentence_object = new Sentence(
        sentences_strings[i][0],
        preamble,
        words,
        sentences_strings.length > 2 ? sentences_strings[i][2] : null,
        i + 1
    );
    if (sentences_strings[i][0] < 0) {
        fillerSentences.push(sentence_object);
    }
    else if (sentences_strings[i][0] > 0) {
        realSentences.push(sentence_object);
    }
    else {
        tempArrayOfPracticeSentences.push(sentence_object);
    }
}
fisherYates(realSentences);
fisherYates(fillerSentences);
// Evenly distribute fillers through the real sentences.
var sentences = null;
if (fillerSentences.length > 0 && realSentences.length > 0) {
    var len = realSentences.length + fillerSentences.length;
    sentences = new Array(len);
    var fillerSpacing = (realSentences.length + 0.0) /
                        (fillerSentences.length + 0.0);
    var moreFillers = fillerSpacing < 0 ?
                          Math.round(1/fillerSpacing) :
                          null;
    var fewerFillers = fillerSpacing > 0 ?
                           Math.round(fillerSpacing) :
                           null;
    var realIndex = 0;
    var fillerIndex = 0;
    var sentencesIndex = 0;
    if (moreFillers != null) {
        while (sentencesIndex < len) {
            for (var i = 0; i < moreFillers; ++i) {
                if (fillerIndex < fillerSentences.length) {
                    sentences[sentencesIndex++] =
                        fillerSentences[fillerIndex++];
                }
            }
            if (realIndex < realSentences.length) {
                sentences[sentencesIndex++] =
                    realSentences[realIndex++];
            }
        }
    }
    else if (fewerFillers != null) {
        while (sentencesIndex < len) {
            if (fillerIndex < fillerSentences.length) {
                sentences[sentencesIndex++] = fillerSentences[fillerIndex++]
            }
            for (var i = 0; i < fewerFillers; ++i) {
                if (realIndex < realSentences.length) {
                    sentences[sentencesIndex++] = realSentences[realIndex++];
                }
            }
        }
    }
}
else if (realSentences.length == 0) {
    sentences = fillerSentences;
}
else {
    sentences = realSentences;
}
// Add the practice sentences at the beginning.
sentences = tempArrayOfPracticeSentences.concat(sentences);

var progressBarHeight = "0.8em";
var progressBarWidth = sentences.length * 5 < 300 ? sentences.length * 5 : 300;
var showProgress = document.createElement("div");
showProgress.className = "lpad";
showProgress.style.marginTop = "2em";
var barContainer = document.createElement("div");
barContainer.className = "bar-container"
barContainer.style.height = progressBarHeight;
barContainer.style.width = progressBarWidth;
var bar = document.createElement("div");
bar.className = "bar";
bar.style.width = "0";
bar.style.height = progressBarHeight;
barContainer.appendChild(bar);
var p = document.createElement("p");
p.className = "progress-text"
p.appendChild(document.createTextNode("progress"));
showProgress.appendChild(barContainer);
showProgress.appendChild(p);

var showSentence = document.createElement("p");
showSentence.style.paddingTop = "1em";
showSentence.appendChild(document.createElement("div")); // Initial dummy child.

var showProgressAndSentenceGroup = document.createElement("div");
showProgressAndSentenceGroup.appendChild(showProgress);
var practiceP = document.createElement("p");
practiceP.className = "lpad practice-text";
practiceP.appendChild(document.createTextNode("Practice sentence"));
showProgressAndSentenceGroup.appendChild(practiceP);
showProgressAndSentenceGroup.appendChild(showSentence);
// Set practiceP to invisible if there aren't any practice sentences.
if (sentences[0].type != 0) {
    practiceP.style.visibility = 'hidden';
}

var resultsHaveBeenSentToServer = false;

var sentenceDivs = new Array(sentences.length);
var wordDivs = new Array(sentences.length);
for (var i = 0; i < sentences.length; ++i) {
    var p = document.createElement("div");
    p.className = "sentence";
    sentenceDivs[i] = p;

    if (sentences[i].preamble) {
        var ppr = document.createElement("p");
        ppr.className = "preamble";
        ppr.appendChild(document.createTextNode(preamble));
        p.appendChild(ppr);
    }

    wordDivs[i] = new Array(sentences[i].words.length);
    for (var j = 0; j < sentences[i].words.length; ++j) {
        div = document.createElement("div");
        div.appendChild(document.createTextNode(sentences[i].words[j]));
        p.appendChild(div)
        wordDivs[i][j] = div;
    }
}

var questionPs = new Array(sentences.length);
var answerNumbers = new Array(sentences.length);
for (var i = 0; i < sentences.length; ++i) {
    // Is there a comprehension question for this sentence?
    if (! sentences[i].question) { continue; }

    var p = document.createElement("p");
    p.className = "question";
    questionPs[i] = p;

    p.appendChild(document.createTextNode(sentences[i].question[0]));

    var correctAnswer = sentences[i].question[1];
    var shuffled = sentences[i].question.slice(1);
    // Special hack: if the options are "yes" and "no", we always present them
    // in "yes/no" order.
    var lc0 = shuffled[0].toLowerCase();
    var lc1 = shuffled[1].toLowerCase();
    if ((lc0 == "yes" || lc0 == "no") && (lc1 == "yes" || lc1 == "no")) {
        shuffled = [lc0 == "yes" ? shuffled[0] : shuffled[1],
                    lc1 == "yes" ? shuffled[0] : shuffled[1]];
    }
    else {
        fisherYates(shuffled);
    }

    var ol = document.createElement("ol");
    for (var j = 0; j < shuffled.length; ++j) {
        if (shuffled[j] == correctAnswer) { answerNumbers[i] = j + 1; }

        var li = document.createElement("li");
        var a = document.createElement("a");
        a.href = "javascript:handleAnswer(" + (j + 1) + ");";
        a.appendChild(document.createTextNode(shuffled[j]));
        li.appendChild(a);
        ol.appendChild(li);
    }
    p.appendChild(ol);

    div = document.createElement("div");
    div.className = "number-message"
    div.appendChild(document.createTextNode("Use number keys or click on links to answer"));
    p.appendChild(div);
}

var noQuestionP = document.createElement("p");
noQuestionP.className = "lpad next-sentence-message";
noQuestionP.appendChild(
    document.createTextNode("Press space to continue")
);

var times = new Array(sentences.length);
for (var i = 0; i < times.length; ++i) {
    times[i] = new Array(sentences[i].words.length - 1);
}
var answers = new Array(sentences.length); // Answers to comprehension Qs.
var newlines = new Array(sentences.length); // Records of when reader went on
                                            // to another line.
for (var i = 0; i < newlines.length; ++i) {
    newlines[i] = new Array(sentences[i].words.length - 1);
}
var currentSentence = 0;
var currentWord = 0;
var currentTime = 0;
var previousTime = null;
var finished = false;
var state = "initial"; // Either "initial", "sentence", "question" or
                       // "no_question".

function setProgressBar(fraction) {
    bar.style.width = Math.round(progressBarWidth * fraction) + "px";
}

function moveOn() {
    ++currentSentence;
    if (currentSentence == sentences.length) {
        finished = true;
        var finishedP = document.createElement("p");
        finishedP.className = "lpad finished-message";
        finishedP.appendChild(document.createTextNode("Finished!"));
        setProgressBar(1);
        showSentence.replaceChild(finishedP, showSentence.firstChild);
        sendResults();
        return;
    }
    else {
        // Show the new sentence (note that currentSentence has been
        // incremented above).
        showSentence.replaceChild(sentenceDivs[currentSentence],
                                  showSentence.firstChild);
        setProgressBar(currentSentence / sentences.length);

        // Are we still in practice sentences?
        if (sentences[currentSentence].type != 0) {
            practiceP.style.visibility = "hidden";
        }

        previousTime = null;
        currentWord = 0;
        currentTime = 0;

        state = "sentence";
    }
}

function handleAnswer(n) {
    // Was the number pressed within the range of answers available?
    if (n <= sentences[currentSentence].question.length - 1) {
        // It is in range, so is it the right answer?
        if (n == answerNumbers[currentSentence]) {
            answers[currentSentence] = 1;
        }
        else {
            answers[currentSentence] = 0;
        }
        moveOn();
    }
}

// Wait for keyboard input.
document.onkeydown = 
    function (e) {
        // Record the time as soon as possible.
        var time = new Date().getTime();

        // For IE.
        if (! e) {
            e = window.event;
        }

        if ((state == "initial") && e.keyCode == 32) {
            state = "sentence";
            document.getElementById("instructions").style.visibility = "hidden";
            showSentence.replaceChild(sentenceDivs[0], showSentence.firstChild);
            body.replaceChild(showProgressAndSentenceGroup,
                              document.getElementById("instructions"));
        }
        else if (! finished) {
            if (state == "sentence" && e.keyCode == 32) {
                var wc = null;
                var wprev = null;
                if (currentWord < sentences[currentSentence].words.length) {
                    wc = wordDivs[currentSentence][currentWord];
                    wc.style.borderColor = "black";
                    wc.style.color = "black";
                }
                if (currentWord > 0) {
                    wprev = wordDivs[currentSentence][currentWord - 1];
                    wprev.style.borderColor = "#9ea4b1";
                    wprev.style.color = "white";
                }

                // Is this the first word on a new line?
                if (wc && wprev) {
                    newlines[currentSentence][currentWord - 1] =
                        (wc.offsetTop != wprev.offsetTop) ? 1 : 0;
                }

                // Don't record a time if this was the keypress that makes the
                // last word of a sentence disappear.
                if (currentWord < sentences[currentSentence].words.length) {
                    // Don't record a time if this is the first word in the
                    // sentence.
                    if (previousTime) {
                        times[currentSentence][currentTime++] =
                            time - previousTime;
                        previousTime = time;
                    }
                    else {
                        previousTime = time;
                    }

                    ++currentWord;
                }
                else {
                    // Is there a comprehension question for this sentence?
                    if (sentences[currentSentence].question) {
                        state = "question";
                        showSentence.replaceChild(questionPs[currentSentence],
                                              showSentence.firstChild);
                    }
                    else {
                        answers[currentSentence] = -1; // Indicate that there
                                                       // was no question.
                        // Don't show the "press space" message if that was
                        // the last sentence.
                        if (currentSentence < sentences.length - 1) {
                            state = "no_question";
                            showSentence.replaceChild(noQuestionP,
                                                      showSentence.firstChild);
                        }
                        else {
                            moveOn();
                            // 'finished' variable now set to true.
                        }
                    }
                }

                // Use this to check that the computation in this function isn't
                // taking long enough to distort results.
                //alert(new Date().getTime() - time);

                // Prevents this being handled by the browser as a pagedown.
                return false;
            }
            else if (state == "question" &&
                     ((e.keyCode >= 48 && e.keyCode <= 57) ||
                      (e.keyCode >= 96 && e.keyCode <= 105))) {
                var n = e.keyCode <= 57 ? e.keyCode - 48 : e.keyCode - 96;
                handleAnswer(n);
            }
            else if (state == "no_question" && e.keyCode == 32) {
                moveOn();
            }
        }
    };

function indicateThatResultsWereSent(success)
{
    if (success) {
        alert("The results were successfully sent to the server. Thanks!");
    }
    else {
        alert("There was an error sending the results to the server.");
    }
}

function getXMLHttpRequest()
{
    if (window.XMLHttpRequest) {
        return new XMLHttpRequest()
    }
    else if (window.ActiveXObject) {
        return new ActiveXObject("Microsoft.XMLHTTP")
    }
    else {
        return null;
    }
}

// Make a post request to a given address. Address may either be a domain
// or an IP.
function sendResults(address, port)
{
    if (resultsHaveBeenSentToServer)
        { return; }

    var xmlhttp = getXMLHttpRequest();
    if (! xmlhttp) {
        indicateThatResultsWereSent(false);
        return;
    }

    // Prepare the POST data.
    data = [sentences, times, answers, newlines].toJSONString();

    xmlhttp.onreadystatechange = function() {
        if (xmlhttp.readyState == 4) {
            if (xmlhttp.status == 200) {
                // Great, we successfully sent the results to the server.
                resultsHaveBeenSentToServer = true;
                indicateThatResultsWereSent(true);
            }
            else {
                // There was an error sending the results.
                indicateThatResultsWereSent(false);
            }
        }
    };
    xmlhttp.open("POST", "/send-results", true);
    xmlhttp.send(data);
}

// Shuffle an array.
function fisherYates(myArray) {
    var i = myArray.length;
    if (i == 0) { return false; }
    while (--i) {
        var j = Math.floor(Math.random() * (i + 1));
        var tempi = myArray[i];
        var tempj = myArray[j];
        myArray[i] = tempj;
        myArray[j] = tempi;
   }
}

document.getElementById("instructions").style.visibility = "visible";
-->
</script>


<!--
    This is some copy/pasted public domain code for serializing Javascript
    data structures in the JSON format; nothing to do with the main
    functionality.
-->
<script type="text/javascript">
<!--

// Augment the basic prototypes if they have not already been augmented.

if (!Object.prototype.toJSONString) {

    Array.prototype.toJSONString = function () {
        var a = ["["],  // The array holding the text fragments.
            b,          // A boolean indicating that a comma is required.
            i,          // Loop counter.
            l = this.length,
            v;          // The value to be stringified.

        function p(s) {

// p accumulates text fragments in an array. It inserts a comma before all
// except the first fragment.

            if (b) {
                a.push(",");
            }
            a.push(s);
            b = true;
        }

// For each value in this array...

        for (i = 0; i < l; i += 1) {
            v = this[i];
            switch (typeof v) {

// Serialize a JavaScript object value. Ignore objects thats lack the
// toJSONString method. Due to a specification error in ECMAScript,
// typeof null is "object", so watch out for that case.

            case "object":
                if (v) {
                    if (typeof v.toJSONString === "function") {
                        p(v.toJSONString());
                    }
                } else {
                    p("null");
                }
                break;

// Otherwise, serialize the value.

            case "string":
            case "number":
            case "boolean":
                p(v.toJSONString());

// Values without a JSON representation are ignored.

            }
        }

// Join all of the fragments together and return.

        a.push("]");
        return a.join("");
    };


    Boolean.prototype.toJSONString = function () {
        return String(this);
    };


    Date.prototype.toJSONString = function () {

// Ultimately, this method will be equivalent to the date.toISOString method.

        function f(n) {

// Format integers to have at least two digits.

            return n < 10 ? "0" + n : n;
        }

        return "\"" + this.getFullYear() + "-" +
                f(this.getMonth() + 1) + "-" +
                f(this.getDate()) + "T" +
                f(this.getHours()) + ":" +
                f(this.getMinutes()) + ":" +
                f(this.getSeconds()) + "\"";
    };


    Number.prototype.toJSONString = function () {

// JSON numbers must be finite. Encode non-finite numbers as null.

        return isFinite(this) ? String(this) : "null";
    };


    Object.prototype.toJSONString = function () {
        var a = ["{"],  // The array holding the text fragments.
            b,          // A boolean indicating that a comma is required.
            k,          // The current key.
            v;          // The current value.

        function p(s) {

// p accumulates text fragment pairs in an array. It inserts a comma before all
// except the first fragment pair.

            if (b) {
                a.push(",");
            }
            a.push(k.toJSONString(), ":", s);
            b = true;
        }

// Iterate through all of the keys in the object, ignoring the proto chain.

        for (k in this) {
            if (this.hasOwnProperty(k)) {
                v = this[k];
                switch (typeof v) {

// Serialize a JavaScript object value. Ignore objects that lack the
// toJSONString method. Due to a specification error in ECMAScript,
// typeof null is "object", so watch out for that case.

                case "object":
                    if (v) {
                        if (typeof v.toJSONString === "function") {
                            p(v.toJSONString());
                        }
                    } else {
                        p("null");
                    }
                    break;

            case "string":
            case "number":
            case "boolean":
                    p(v.toJSONString());

// Values without a JSON representation are ignored.

                }
            }
        }

// Join all of the fragments together and return.

        a.push("}");
        return a.join("");
    };


    (function (s) {

// Augment String.prototype. We do this in an immediate anonymous function to
// avoid defining global variables.

// m is a table of character substitutions.

        var m = {
            "\b": "\\b",
            "\t": "\\t",
            "\n": "\\n",
            "\f": "\\f",
            "\r": "\\r",
            "\"" : "\\\"",
            "\\": "\\\\"
        };


        s.parseJSON = function (filter) {

// Parsing happens in three stages. In the first stage, we run the text against
// a regular expression which looks for non-JSON characters. We are especially
// concerned with "()" and "new" because they can cause invocation, and "="
// because it can cause mutation. But just to be safe, we will reject all
// unexpected characters.

            try {
                if (/^("(\\.|[^"\\\n\r])*?"|[,:{}\[\]0-9.\-+Eaeflnr-u \n\r\t])+?$/.
                        test(this)) {

// In the second stage we use the eval function to compile the text into a
// JavaScript structure. The "{" operator is subject to a syntactic ambiguity
// in JavaScript: it can begin a block or an object literal. We wrap the text
// in parens to eliminate the ambiguity.

                    var j = eval("(" + this + ")");

// In the optional third stage, we recursively walk the new structure, passing
// each name/value pair to a filter function for possible transformation.

                    if (typeof filter === "function") {

                        function walk(k, v) {
                            if (v && typeof v === "object") {
                                for (var i in v) {
                                    if (v.hasOwnProperty(i)) {
                                        v[i] = walk(i, v[i]);
                                    }
                                }
                            }
                            return filter(k, v);
                        }

                        j = walk("", j);
                    }
                    return j;
                }
            } catch (e) {

// Fall through if the regexp test fails.

            }
            throw new SyntaxError("parseJSON");
        };


        s.toJSONString = function () {

// If the string contains no control characters, no quote characters, and no
// backslash characters, then we can simply slap some quotes around it.
// Otherwise we must also replace the offending characters with safe
// sequences.

            if (/["\\\x00-\x1f]/.test(this)) {
                return "\"" + this.replace(/([\x00-\x1f\\"])/g, function(a, b) {
                    var c = m[b];
                    if (c) {
                        return c;
                    }
                    c = b.charCodeAt();
                    return "\\u00" +
                        Math.floor(c / 16).toString(16) +
                        (c % 16).toString(16);
                }) + "\"";
            }
            return "\"" + this + "\"";
        };
    })(String.prototype);
}
-->
</script>
<noscript>
You need to have Javascript enabled in order to use this page.
</noscript>

</body>
</html>

